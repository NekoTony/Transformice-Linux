"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getResolvedPublishConfig = exports.Publisher = undefined;

var _bluebirdLstC;

function _load_bluebirdLstC() {
    return _bluebirdLstC = require("bluebird-lst-c");
}

let getResolvedPublishConfig = exports.getResolvedPublishConfig = (() => {
    var _ref = (0, (_bluebirdLstC || _load_bluebirdLstC()).coroutine)(function* (packager, publishConfig, errorIfCannot) {
        let getInfo = (() => {
            var _ref2 = (0, (_bluebirdLstC || _load_bluebirdLstC()).coroutine)(function* () {
                const info = yield packager.repositoryInfo;
                if (info != null) {
                    return info;
                }
                if (!errorIfCannot) {
                    return null;
                }
                throw new Error(`Cannot detect repository by .git/config. Please specify "repository" in the package.json (https://docs.npmjs.com/files/package.json#repository).\nPlease see https://github.com/electron-userland/electron-builder/wiki/Publishing-Artifacts`);
            });

            return function getInfo() {
                return _ref2.apply(this, arguments);
            };
        })();

        if (publishConfig.provider === "generic") {
            if (publishConfig.url == null) {
                throw new Error(`Please specify "url" for "generic" update server`);
            }
            return publishConfig;
        }

        let owner = publishConfig.owner;
        let project = publishConfig.provider === "github" ? publishConfig.repo : publishConfig.package;
        if (!owner || !project) {
            const info = yield getInfo();
            if (info == null) {
                return null;
            }
            if (!owner) {
                owner = info.user;
            }
            if (!project) {
                project = info.project;
            }
        }
        const copy = Object.assign({}, publishConfig);
        if (copy.owner == null) {
            copy.owner = owner;
        }
        if (publishConfig.provider === "github") {
            const options = copy;
            if (options.repo == null) {
                options.repo = project;
            }
            return options;
        } else if (publishConfig.provider === "bintray") {
            const options = copy;
            if (options.package == null) {
                options.package = project;
            }
            return options;
        } else {
            return null;
        }
    });

    return function getResolvedPublishConfig(_x, _x2, _x3) {
        return _ref.apply(this, arguments);
    };
})();

exports.getCiTag = getCiTag;

var _uploader;

function _load_uploader() {
    return _uploader = require("./uploader");
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = require("fs-extra-p");
}

var _path = require("path");

class Publisher {
    upload(file, artifactName) {
        var _this = this;

        return (0, (_bluebirdLstC || _load_bluebirdLstC()).coroutine)(function* () {
            const fileName = artifactName || (0, _path.basename)(file);
            const fileStat = yield (0, (_fsExtraP || _load_fsExtraP()).stat)(file);
            yield _this.doUpload(fileName, fileStat.size, (_uploader || _load_uploader()).uploadFile.bind(_this, file, fileStat, fileName));
        })();
    }
    uploadData(data, fileName) {
        if (data == null || fileName == null) {
            throw new Error("data or fileName is null");
        }
        return this.doUpload(fileName, data.length, it => it.end(data));
    }
}
exports.Publisher = Publisher;
function getCiTag() {
    const tag = process.env.TRAVIS_TAG || process.env.APPVEYOR_REPO_TAG_NAME || process.env.CIRCLE_TAG || process.env.CI_BUILD_TAG;
    return tag != null && tag.length > 0 ? tag : null;
}
//# sourceMappingURL=publisher.js.map